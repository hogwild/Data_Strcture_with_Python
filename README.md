# Data_Strcture_with_Python
## Chapter 1 绪论
本章讨论了一些与数据结构和算法有关的基础问题，包括：
1. 程序开发过程：
   - 分析阶段
   - 设计阶段
   - 编码阶段
   - 检查测试阶段
   - 测试/调试阶段
2. 问题求解：
   - 问题分析和严格化
   - 算法提出
   - 算法的精化和Python描述
3. 算法和算法分析
   - 问题和算法
   - 算法的代价及其度量
   - 算法分析
4. 数据结构
   - 数据结构及其分类：
     - 集合结构
     - 序列结构
     - 层次结构
     - 树形结构
     - 图结构


## Chapter 2 抽象数据和Python类
本章介绍了抽象数据类型（Abstract Data Type）的概念。
- 在程序开发实践中，人们逐渐认识到，仅有计算层面的抽象机制和抽象定义还不够，还需要考虑数据层面的抽象。能围绕一类数据建立程序组件，将该类数据的具体表示和相关操作的实现包装成一个整体，也是组织复杂程序的一种有效技术，可以用于开发各种有用的程序模块。
- 要把这种围绕着一类数据对象构造的模块做成数据抽象，同样需要区分模块的接口和实现。模块接口提供使用它提供的功能所需的所有信息，但不涉及具体实现细节，另一方面，模块实现者则要通过模块内部的一套数据定义和函数（过程）定义，实现模块接口所有的功能，从形式上和实际效果上满足模块接口的要求。
- 数据类型
  - 每种语言都提供了一组内置数据类型，为每个内置类型提供了一批操作（比如，整数的加减乘除等）。Python提供的基本类型包括：bool, int, float, str等。
  - 无论编程语言提供了多少内置类型，在处理复杂的问题时，程序员或早或晚都会遇到一些情况，此时，各种内置类型都不能满足或者不适合于自己的需要。在这种情况下，编程语言提供的组合类型有可能帮助解决一些问题。Python为数据的组合提供了 list, tuple, set, dict等结构（它们也可以看做是类型），编程时可以利用它们把一组相关数据组织在一起，构成一个数据对象，作为整体存储，传递和处理。
- 抽象数据类型：把对象的使用与其具体实现隔离开
  - 抽象数据类型的基本思想是把数据定义为抽象的对象集合，只为它们定义可用的个发操作，并不暴露其内部实现的具体细节，不论是其数据表示细节还是操作的实现细节。一个数据类型的操作通常可以分为三类：
    - 构造操作
    - 解析操作
    - 变动操作
  - 抽象数据类型的描述
    - 定义一个抽象数据类型，目的是要定义一类计算对象，它们具有某些特定的功能，可以在计算中使用。这类对象的功能体现为一组可以对它们使用的操作。当然，还需要为这一抽象数据类型确定一个类型名。
  - ADT是一种思想，也是一种组织程序的技术，主要包括：
    - 围绕着一类数据定义程序模块。
    - 模块的接口和实现分离。在ADT描述中，一般给出的是模块的接口规范，包括模块名，模块提供的各个操作的名字和参数。每个操作还有非形式化的语义说明。
    - 在需要实现时，从所用的编程语言里选一套合适的机制，采用合理的技术，实现这种ADT的功能，包括具体的数据表示和操作。

## Chaper 3 线性表
一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。它是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。
- 线性表的数学定义：集合 $E$ 上的一个线性表就是E中一组有穷个元素排成的序列 $L=(e_0, e_1,\cdots,e_{n-1})$,其中 $e_i\in E$ 且 $n\ge 0$。在这个表里可以包含 0 个或多个元素，序列中的每个元素在表里有一个确定的位置，成为该元素的**下标**。不包含任何元素的表称为**空表**。表元素之间存在着一个基本关系，称为**下一个关系**。对于表 $L$，其下一个关系是二元组的集合 $\{<e_0,e_1>, <e_1, e_2>, \cdots, <e_{n-2}, e_{n-1}>\}$。下一个关系是一种**顺序关系**,即**线性关系**。线性表是一种线性结构。
- 在一个非空的线性表里，存在着唯一的首元素和唯一的尾元素，除了首元素之外，表中每个元素都有且仅有一个前驱元素；除了尾元素之外的每个元素都有且仅有一个后继元素。
#### 表抽象数据类型
需要从**实现者**和**使用者**的角度分别考虑表的**抽象描述**：
- 实现者：
  - 如何把该结构内部的数据组织好，为它设计一种合适的表示
  - 如何提供一套有用而且必要的操作，并有效实现这些操作
- 使用者：
  - 考虑该结构提供了哪些操作
  - 如何有效使用以解决自己的问题
##### The ADT
- ADT List:        #一个表抽象数据类型
  - List(self)     #表构造操作，创建一个新表
  - is_empty(self) #判断self是否为一个空表
  - len(self)      #获得self的长度
  - prepend(self, elem) #将元素elem加入表中作为第一个元素
  - append(self, elem)  #将元素elem加入表中作为最后一个元素
  - insert(self, elem, i)  #将elem加入表中作为第i个元素，其他元素的顺序不变
  - del_first(self)        #删除表中的第一个元素
  - del_last(self)         #删除表中的尾元素
  - del(self, i)           #删除表中的第i个元素
  - search(self, elem)     #查找元素elem在表中出现的位置，不出现时返回 -1
  - forall(self, op)       #对表中的每一个元素执行操作op
#### 线性表的实现模型（两种）
- 顺序表：将表中元素顺序地放在一大块连续的存储区域里
  - 一体式结构
  - 分离式结构：动态顺序表
  - Python 的 list 和 tuple 就采用了顺序表的实现技术。list采用了分离式技术实现的动态顺序表。
- 链接表
  - 单链表
  - 带有尾结点的单链表
  - 循环单链表
  - 双链表

## Chapter 4 字符串
- 字符串可以看作一类特殊的线性表，表中元素取自自选元素的字符集。
#### 字符串的匹配算法
- 朴素匹配算法
- KMP算法 （无回溯串匹配算法）
#### Python正则表达式

## Chapter 5 栈和队列
- 在常用的数据结构中，有一批结构被成为**容器**。
- 一个**容器**结构里总包含一组其他类型的数据对象，称为**元素**,支持对这些元素的存储，管理，和使用。
- 一类**容器**具有相同性质，支持同一组操作，就可以被定义为一个**抽象数据类型**。
- 两种最常用的容器：**栈** (stack) 和 **队列** (queue)。
####缓冲存储（缓存）
- 计算中，如果需要存储的数据项数不能事先确定，就必须采用更复杂的机制存储和管理，这样的存储机制称为**缓冲存储**(缓存)。
- **栈**和**队列**是一种**缓冲存储结构**，主要用于在计算过程中保存零时数据，这些数据是计算中发现或者产生的，在后面的计算中可能需要使用它们。
- 栈是保证元素**后进先出**关系的结构（LIFO）
- 队列是保证元素**先进先出**关系的结构（FIFO）
- 由于计算机存储器的特点，要实现栈或队列，最自然的技术就是用元素的存储顺序表示它们的时间顺序，所以，应该用**线性表**作为栈和队列的**实现结构**。
#### 栈
- 栈确定了一种默认元素的访问顺序，访问时无需其他信息。
- **ADT stack**:
  - Stack(self)    #创建空栈
  - is_empty(self) #判断栈是否为空，空时返回True否则返回False
  - push(self, elem) #将元素elem加入栈，也常称为**压入**或者**推入**
  - pop(self)        #删除栈里最后压入的元素并将其返回，常称为**弹出**
  - top(self)        #取得栈里最后压入的元素，不删除
- 栈的顺序表实现：对于**顺序表**，后端插入和删除是O(1)操作，应该用**后端**作为栈顶
- 栈的链接表实现：对于**链接表**，前端插入和删除是O(1)操作，应该用**前端**作为栈顶
- 栈和递归：
  - **递归定义**：如果在一个定义中引用了被定义的对象(被定义的函数)本身，这种定义被称为递归定义。
  - **Python的递归调用**：Python语言里定义一个函数时，允许在函数的定义体里出现对这个函数自身的调用。
  - 递归的例子：
    - 结点通过链接构成单链表，是递归结构的一个实例
  - 在计算机上如何实现递归：
    - 程序运行栈：用一个栈保存递归函数执行时每层调用的局部信息，留待函数调用返回后继续使用。
      - 函数帧：编程语言对rec(递归定义的函数)的每个调用都在运行栈上为之开辟一块区域，称为函数帧（简称帧）。
- 栈和函数调用：
  - 在基于栈的函数调用执行中，需要做一些规范的动作，这些动作在实际的程序代码中没有写出，但是在程序执行中，需要由语言系统在内部完成。这些内部动作分为两部分：
    - 前序动作：
      - 为被调用函数的局部变量和形式参数分配存储区（称为函数帧/活动记录/数据区）
      - 将所有实参和函数的返回地址存入函数帧（实参形参的结合/传值）
      - 将控制转到被调用的函数入口
    - 后序动作：
      - 将被调用的函数的计算结果存入指定位置
      - 释放被调用函数的存储区（帧）
      - 按以前保存的返回地址将控制转回调用函数
  - 函数调用是有代价的：在得到程序代码的模块化和语义清晰等优势的同时，可能付出了执行时间的代价。
    - 新型处理器结构都针对函数调用的实现做了专门的优化设计，大大减少了函数调用带来的程序性能下降。
  - 可以证明：任何一个递归定义的函数（程序），都可以**通过引入一个栈保存中间结果的方式**，翻译为一个非递归的过程。
    - 与此对应，任何一个包含循环的程序都可以翻译为一个不包含循环的递归函数。
    - 如果遇到一个递归算法，希望做出它的一个非递归实现，更合适的方法是分析算法的具体情况，弄清计算细节，然后根据得到的认识自己设计出相应的非递归函数。
    - 很多简单的情况中可能并不需要用栈，但一般情况下需要一个栈。

#### 队列
- 队列中也没有位置的概念，只支持默认方式的元素存入和取出。
- **ADT Queue**:
  - QUeue(self)   #创建空队列
  - is_empty(self) #判断队列是否为空，空时返回True否则返回False
  - enqueue(self, elem) #将元素elem加入队列，常称为**入队**
  - dequeue(self) #删除队列里最早进入的元素并将其返回，常称为**出队**
  - peek(self) #查看队列里最早进入的元素，不删除

- 队列基于链接表的实现：带尾端指针的单链表，支持O(1)时间的首端插入/删除操作，已经O(1)时间的尾端插入操作。
- 队列基于顺序表的实现:
  - 循环顺序表
- 队列的list实现

#### 迷宫求解和状态空间搜索
- 深度优先搜索(depth-first search)：基于栈的搜索
- 广度优先搜索(width-first search)：基于队列的搜索

#### 补充
- 双端队列：允许在两端插入和删除元素，因此功能上覆盖所有结构，要求两端的四种变动操作都应该具有O(1)时间复杂度。
  - 利用双链表可以实现双端队列

## Chapter 6 二叉树和树
树形结构的由**结点**和**结点之间的连接关系**构成。
- 结点：结构中的逻辑单元，可用于保存数据
- 结点之间连接关系：一种后继关系

树型结构的特征：
- 一个结构如果不空，其中就存在着唯一的**起始结点**，称为**树根(root)**。
- 按结构的连接关系，**树根之外**的其余结点都有且只有一个**前驱**。一个结点可以有0个或者多个后继。另外，在非空的树结构中一定有些结点并不连接到其他结点。
- 结构里的所有结点都在树根结点通过后继关系可以到达的结点集合里。换句话说，从树根结点出发，经过若干次后继关系可以到达结构中的任一个结点。
- 结点之间的联系不会形成循环关系，这也说明，结点之间的联系形成了一种序，但一般而言不像线性表那样形成一个全序。
- 从这种结构里的任意两个不同结点出发，通过后继关系可达的两个结点集合，或者互相不相交，或者一个集合是另一个集合的子集。

此外，在树型结构里的结点形成了一种层次结构，可用于表示各种常见的层次性关系。

#### 二叉树
二叉树是最简单的树型结构，其特点是每个结点至多关联到两个后继结点，也就是说，一个结点的关联结点数可以为0,1或2。另一个特点是一个关联的后继结点明确地分左右，或为其左关联结点，或为右关联结点。
- **二叉树定义**：二叉树是结点的有穷集合。这个集合或者是空集，或者其中有一个称为根节点的特殊结点，其余结点分属两颗不想交的二叉树，这两颗二叉树分别是原二叉树（或者说是原二叉树的根节点）的**左子树**和**右子树**。
- 二叉树的定义是一个递归定义，所定义的二叉树是一种递归结构。
- 二叉树的两颗子树有明确的左右之分，讨论子树时必须明确说明是**左子树**还是**右子树**。
- 几个概念：
  - 空树：不包含任何结点的二叉树
  - 单点树：只包含一个结点的二叉树
  - 一般而言，一颗二叉树可以包含任意(但有穷多)个结点
  - 一颗二叉树的根结点称为该树的**子树根结点**的**父结点**；子树的根结点称为二叉树树根结点的**子结点**。
  - 父结点到子结点有一条连线，称为**从父结点到子结点的边**。这种边有方向，形成一种单方向的父结点/子结点关系（**父子关系**）。
  - 基于父子关系可以定义其传递关系，称为**祖先/子孙关系**，它决定了一个结点的**祖先结点**，或**子孙结点**。
  - 父结点相同的两个结点互为**兄弟结点**。
  - **树叶**:指那些结点，其两颗子树都是空，没有子结点。
  - **分支结点**：树中除了树叶以外的其余结点，称为分支结点。
  - **二叉树的五种可能形态**：
    - 空二叉树
    - 只有根结点，是单点树
    - 只有根结点和左子树
    - 只有根结点和右子树
    - 两颗子树俱全

  - **度树**：一个结点的子结点个数称为该点的度数。显然二叉树中树叶结点的度数为0，分支结点的度数可以是1或者2。
  - **路径**：从一个祖先结点到其任何子孙结点都存在一系列边，形成从前者到后者的联系。这样**一系列**首尾相连的**边**称为树中的**一条路径**,路径中**边的条数**称为该路径的**长度**。为统一起见，也认为从每个结点到其自身有一条长度为0的路径。
  - 层：二叉树是一种层次结构。将其树根看作最高层元素，如果有子结点，其子结点看作是下一层元素。规定二叉**树根的层数为0**。对位于$k$层的结点，其子结点是$k+1$层的元素，如此下去，二叉树的所有结点可以按这种关系分为一层层的元素。**从根结点到树中任一结点的路径长度就是该结点所在的层数，也称为该结点的层数。**
  - 一颗二叉树的**高度**（也称为深度）是树中结点的最大层数，也就是这颗树里的最长路径的长度。

#### 二叉树的性质：

- 作为数据结构，二叉树最重要的性质就是树的**高度**和**树中可以容纳的最大结点个数**之间的关系。  
  - 在非空二叉树第 $i$ 层中至多有 $2^i$ 个结点 $(i\ge 0)$。
  - 高度为 $h$ 的二叉树至多有 $2^{h+1}-1$ 个结点 $(h\ge 0)$。
  - 对于任何非空二叉树 $T$，如果其叶结点的个数 $n_0$ ，度数为 2 的结点个数为 $n_2$，那么 $n_0 = n_2 +1$。
- 满二叉树，扩充二叉树
  - 如果二叉树中所有分支结点的度数都是2，则称它为一颗**满二叉树**。满二叉树是一般二叉树的一个子集。
    - 性质：满二叉树里的叶结点比分支结点多一个。
  - 扩充二叉树：对二叉树 $T$ 加入足够多的新叶结点，使 $T$ 的原有结点变成度数为 2 的分支结点，得到的二叉树称为 $T$ 的**扩充二叉树**。扩充二叉树中新增的结点称为其外部结点，原树 $T$ 的结点称为其内部结点。
    - 空树的扩充规定为空树。
    - 扩充二叉树的外部结点个数比内部结点的个数多1个。
    - 扩充二叉树的外部路径长度 $E$ 是从树根到树中各外部结点的路径长度之和，内部路径长度 $I$ 是从树根到树中各内部结点的路径长度之和。如果该树有 $n$ 个内部结点，那么 $E = I + 2\times n$。
- 完全二叉树
  - 对于一颗高度为 $h$ 的二叉树，如果其第 0 层至第 $h-1$ 层的结点都满（即，对所有 $0\le i \le h-1$，第 $i$ 层有 $2^i$ 个结点）。如果最下一层的结点不满，则所有结点在最左边连续排列，空位都在右边。这样的二叉树，就是一颗**完全二叉树**。
    - $n$ 个结点的完全二叉树高度 $h = |log_2n|$，即为不大于 $log_2n$ 的最大整数。
  - 下面的这个性质是**完全二叉树最重要的性质**之一，依此可以方便地存入一个表或者数组，直接根据元素下标就能找到一个结点的子结点或父结点（也就是说，完全确定二叉树的结构），如需以其他方式记录树结构信息：
    - 如果 $n$ 个结点的完全二叉树的结点按层次并按从左到右的顺序从 0 开始编号，对任一结点 $i$, $(0\ge i\le n-1)$ 都有：
    - 序号为 0 的结点是根
    - 对于 $i>0$，其父结点的编号是 $(i-1)/2$。
    - 若 $2\times i+1<n$，其左子结点序号为 $2\times i+1$，否则它无左子结点。
    - 若 $2\times i+2<n$，其右子结点序号为 $2\times i+2$，否则它无右子结点。
- 一般而言，对于 $n$ 个结点二叉树有如下情况：
  - 如果它足够“丰满整齐“（即树中很少有度数为1的分支结点，且最长路径的长度差不多），则树中最长路径的长度将为 $O(\log n)$。例如，完全二叉树。
  - 如果它比较"畸形"，则最长路径的长度可能达到 $O(n)$。
  - 对于所有 $n$ 个结点的二叉树，其最长路径的平均值为 $O(\log n)$。

 #### ADT
 - ADT BinTree:
   - BinTree（self, data, left, right)  #构造操作，创建一个新的二叉树
   - is_empty(self)  #判断self是否为一个空二叉树
   - num_nodes(self) #求二叉树的结点个数
   - data(self) #获取二叉树根存储的数据
   - left(self) #获取二叉树的左子树
   - right(self) #获取二叉树的右子树
   - set_left(self, btree) #用btree取代原来的左子树
   - set_right(self,btree) #用btree取代原来的右子树
   - traversal(self) #遍历二叉树中各结点数据的迭代器
   - forall(self,op) #对二叉树中每个结点的数据执行操作 op

#### 遍历二叉树
每颗二叉树有唯一的**根节点**，可以将其看作这颗二叉树的**唯一标识**。
- 根结点识基于树结构的处理过程的入口。实际中，常用二叉树的根结点代表这颗二叉树，其左右子树由它们的根结点代表。
- 二叉树的结构比较复杂，因此系统化遍历有多重可能的方式。和状态搜索类似，以根为起点，存在两种基本的二叉树遍历方式：
  - 深度优先遍历：顺着一条路径尽可能向前探索，必要时回溯。
  - 宽度优先遍历：在所有路径上齐头并进。

###### 深度优先遍历：
- 按深度优先遍历一颗二叉树，需要做三件事：遍历左子树，遍历右子树，和访问根结点。按不同顺序执行这三项工作，可以得到三种常见的遍历顺序：
  - 先根序遍历，得到的是先根序列
  - 中根序遍历(也称对称序)，得到的是对称序列（中根序列）
  - 后根序遍历，得到的是后根序列
- 由于二叉树的子树也是二叉树，将一种具体的遍历顺序继续运用到子树的遍历中，就形成了一种遍历二叉树的统一方法。
- **如果二叉树中每一个结点有唯一的标识，就可以用结点标识描述这些序列**。显然，给定的二叉树唯一确定了它的先根序列，后根序列，和对称序列。
- **如果给定了一颗二叉树的任一种遍历序列，都无法确定唯一相应的二叉树**。
- **命题**：如果知道了一颗二叉树的对称序列，又知道了另一遍历序列（无论是先根还是后根序列），就可以唯一确定这个二叉树。（如何证明？）

##### 宽度优先遍历：
- 宽度优先遍历（又称为按层次顺序遍历），是按路径长度由近到远地访问结点。与状态空间搜索的情况一样，这种遍历不能写成一个递归过程。

##### 遍历与搜索：
- 一颗二叉树可以看做是一个状态空间：根结点对应状态空间的初始状态，父子结点链接对应状态的邻接关系。如此，一次二叉树的遍历可以看作是一次覆盖整个状态空间的搜索。前面所有关于状态空间的搜索方法和实现技术都可以原样移植到二叉树遍历问题中。（如，递归搜索，基于栈的非递归搜索。基于队列的宽度优先搜索对应于这里的层次序遍历。）
- 二叉树遍历中，从一条路走下去绝不会与另一条路相交，不必考虑循环访问的问题。（有助于简化算法的实现)
- 在状态空间的搜索过程中记录从一个状态到另一个状态的联系，将其看作结点间的链接，就会发现这种搜索过程实际上构造出了一颗树，称为**搜索树**。一般而言，这样形成的结构是一般的树，不是二叉树。（无论如何，这种情况进一步说明了，树的遍历与状态空间搜索之间的紧密联系。）
