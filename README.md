# Data_Strcture_with_Python
## Chapter 1 绪论
本章讨论了一些与数据结构和算法有关的基础问题，包括：
1. 程序开发过程：
   - 分析阶段
   - 设计阶段
   - 编码阶段
   - 检查测试阶段
   - 测试/调试阶段
2. 问题求解：
   - 问题分析和严格化
   - 算法提出
   - 算法的精化和Python描述
3. 算法和算法分析
   - 问题和算法
   - 算法的代价及其度量
   - 算法分析
4. 数据结构
   - 数据结构及其分类：
     - 集合结构
     - 序列结构
     - 层次结构
     - 树形结构
     - 图结构


## Chapter 2 抽象数据和Python类
本章介绍了抽象数据类型（Abstract Data Type）的概念。
- 在程序开发实践中，人们逐渐认识到，仅有计算层面的抽象机制和抽象定义还不够，还需要考虑数据层面的抽象。能围绕一类数据建立程序组件，将该类数据的具体表示和相关操作的实现包装成一个整体，也是组织复杂程序的一种有效技术，可以用于开发各种有用的程序模块。
- 要把这种围绕着一类数据对象构造的模块做成数据抽象，同样需要区分模块的接口和实现。模块接口提供使用它提供的功能所需的所有信息，但不涉及具体实现细节，另一方面，模块实现者则要通过模块内部的一套数据定义和函数（过程）定义，实现模块接口所有的功能，从形式上和实际效果上满足模块接口的要求。
- 数据类型
  - 每种语言都提供了一组内置数据类型，为每个内置类型提供了一批操作（比如，整数的加减乘除等）。Python提供的基本类型包括：bool, int, float, str等。
  - 无论编程语言提供了多少内置类型，在处理复杂的问题时，程序员或早或晚都会遇到一些情况，此时，各种内置类型都不能满足或者不适合于自己的需要。在这种情况下，编程语言提供的组合类型有可能帮助解决一些问题。Python为数据的组合提供了 list, tuple, set, dict等结构（它们也可以看做是类型），编程时可以利用它们把一组相关数据组织在一起，构成一个数据对象，作为整体存储，传递和处理。
- 抽象数据类型：把对象的使用与其具体实现隔离开
  - 抽象数据类型的基本思想是把数据定义为抽象的对象集合，只为它们定义可用的个发操作，并不暴露其内部实现的具体细节，不论是其数据表示细节还是操作的实现细节。一个数据类型的操作通常可以分为三类：
    - 构造操作
    - 解析操作
    - 变动操作
  - 抽象数据类型的描述
    - 定义一个抽象数据类型，目的是要定义一类计算对象，它们具有某些特定的功能，可以在计算中使用。这类对象的功能体现为一组可以对它们使用的操作。当然，还需要为这一抽象数据类型确定一个类型名。
  - ADT是一种思想，也是一种组织程序的技术，主要包括：
    - 围绕着一类数据定义程序模块。
    - 模块的接口和实现分离。在ADT描述中，一般给出的是模块的接口规范，包括模块名，模块提供的各个操作的名字和参数。每个操作还有非形式化的语义说明。
    - 在需要实现时，从所用的编程语言里选一套合适的机制，采用合理的技术，实现这种ADT的功能，包括具体的数据表示和操作。

## Chaper 3 线性表
一个线性表是某类元素的一个集合，还记录着元素之间的一种顺序关系。它是最基本的数据结构之一，在实际程序中应用非常广泛，它还经常被用作更复杂的数据结构的实现基础。
- 线性表的数学定义：集合 $E$ 上的一个线性表就是E中一组有穷个元素排成的序列 $L=(e_0, e_1,\cdots,e_{n-1})$,其中 $e_i\in E$ 且 $n\ge 0$。在这个表里可以包含 0 个或多个元素，序列中的每个元素在表里有一个确定的位置，成为该元素的**下标**。不包含任何元素的表称为**空表**。表元素之间存在着一个基本关系，称为**下一个关系**。对于表 $L$，其下一个关系是二元组的集合 $\{<e_0,e_1>, <e_1, e_2>, \cdots, <e_{n-2}, e_{n-1}>\}$。下一个关系是一种**顺序关系**,即**线性关系**。线性表是一种线性结构。
- 在一个非空的线性表里，存在着唯一的首元素和唯一的尾元素，除了首元素之外，表中每个元素都有且仅有一个前驱元素；除了尾元素之外的每个元素都有且仅有一个后继元素。
#### 表抽象数据类型
需要从**实现者**和**使用者**的角度分别考虑表的**抽象描述**：
- 实现者：
  - 如何把该结构内部的数据组织好，为它设计一种合适的表示
  - 如何提供一套有用而且必要的操作，并有效实现这些操作
- 使用者：
  - 考虑该结构提供了哪些操作
  - 如何有效使用以解决自己的问题
##### The ADT
- ADT List:        #一个表抽象数据类型
  - List(self)     #表构造操作，创建一个新表
  - is_empty(self) #判断self是否为一个空表
  - len(self)      #获得self的长度
  - prepend(self, elem) #将元素elem加入表中作为第一个元素
  - append(self, elem)  #将元素elem加入表中作为最后一个元素
  - insert(self, elem, i)  #将elem加入表中作为第i个元素，其他元素的顺序不变
  - del_first(self)        #删除表中的第一个元素
  - del_last(self)         #删除表中的尾元素
  - del(self, i)           #删除表中的第i个元素
  - search(self, elem)     #查找元素elem在表中出现的位置，不出现时返回 -1
  - forall(self, op)       #对表中的每一个元素执行操作op
#### 线性表的实现模型（两种）
- 顺序表：将表中元素顺序地放在一大块连续的存储区域里
  - 一体式结构
  - 分离式结构：动态顺序表
  - Python 的 list 和 tuple 就采用了顺序表的实现技术。list采用了分离式技术实现的动态顺序表。
- 链接表
  - 单链表
  - 带有尾结点的单链表
  - 循环单链表
  - 双链表

## Chapter 4 字符串
- 字符串可以看作一类特殊的线性表，表中元素取自自选元素的字符集。
#### 字符串的匹配算法
- 朴素匹配算法
- KMP算法 （无回溯串匹配算法）
#### Python正则表达式

## Chapter 5 栈和队列
- 在常用的数据结构中，有一批结构被成为**容器**。
- 一个**容器**结构里总包含一组其他类型的数据对象，称为**元素**,支持对这些元素的存储，管理，和使用。
- 一类**容器**具有相同性质，支持同一组操作，就可以被定义为一个**抽象数据类型**。
- 两种最常用的容器：**栈** (stack) 和 **队列** (queue)。
####缓冲存储（缓存）
- 计算中，如果需要存储的数据项数不能事先确定，就必须采用更复杂的机制存储和管理，这样的存储机制称为**缓冲存储**(缓存)。
- **栈**和**队列**是一种**缓冲存储结构**，主要用于在计算过程中保存零时数据，这些数据是计算中发现或者产生的，在后面的计算中可能需要使用它们。
- 栈是保证元素**后进先出**关系的结构（LIFO）
- 队列是保证元素**先进先出**关系的结构（FIFO）
- 由于计算机存储器的特点，要实现栈或队列，最自然的技术就是用元素的存储顺序表示它们的时间顺序，所以，应该用**线性表**作为栈和队列的**实现结构**。
#### 栈
- 栈确定了一种默认元素的访问顺序，访问时无需其他信息。
- ADT stack:
  - Stack(self)    #创建空栈
  - is_empty(self) #判断栈是否为空，空时返回True否则返回False
  - push(self, elem) #将元素elem加入栈，也常称为**压入**或者**推入**
  - pop(self)        #删除栈里最后压入的元素并将其返回，常称为**弹出**
  - top(self)        #取得栈里最后压入的元素，不删除
- 栈的顺序表实现：对于**顺序表**，后端插入和删除是O(1)操作，应该用**后端**作为栈顶
- 栈的链接表实现：对于**链接表**，前端插入和删除是O(1)操作，应该用**前端**作为栈顶
- 栈和递归：
  - **递归定义**：如果在一个定义中引用了被定义的对象(被定义的函数)本身，这种定义被称为递归定义。
  - **Python的递归调用**：Python语言里定义一个函数时，允许在函数的定义体里出现对这个函数自身的调用。
  - 递归的例子：
    - 结点通过链接构成单链表，是递归结构的一个实例
  - 在计算机上如何实现递归：
    - 程序运行栈：用一个栈保存递归函数执行时每层调用的局部信息，留待函数调用返回后继续使用。
      - 函数帧：编程语言对rec(递归定义的函数)的每个调用都在运行栈上为之开辟一块区域，称为函数帧（简称帧）。
- 栈和函数调用：
  - 在基于栈的函数调用执行中，需要做一些规范的动作，这些动作在实际的程序代码中没有写出，但是在程序执行中，需要由语言系统在内部完成。这些内部动作分为两部分：
    - 前序动作：
      - 为被调用函数的局部变量和形式参数分配存储区（称为函数帧/活动记录/数据区）
      - 将所有实参和函数的返回地址存入函数帧（实参形参的结合/传值）
      - 将控制转到被调用的函数入口
    - 后序动作：
      - 将被调用的函数的计算结果存入指定位置
      - 释放被调用函数的存储区（帧）
      - 按以前保存的返回地址将控制转回调用函数
  - 函数调用是有代价的：在得到程序代码的模块化和语义清晰等优势的同时，可能付出了执行时间的代价。
    - 新型处理器结构都针对函数调用的实现做了专门的优化设计，大大减少了函数调用带来的程序性能下降。
  - 可以证明：任何一个递归定义的函数（程序），都可以**通过引入一个栈保存中间结果的方式**，翻译为一个非递归的过程。
    - 与此对应，任何一个包含循环的程序都可以翻译为一个不包含循环的递归函数。
    - 如果遇到一个递归算法，希望做出它的一个非递归实现，更合适的方法是分析算法的具体情况，弄清计算细节，然后根据得到的认识自己设计出相应的非递归函数。
    - 很多简单的情况中可能并不需要用栈，但一般情况下需要一个栈。

#### 队列
- 队列中也没有位置的概念，只支持默认方式的元素存入和取出。
- ADT Queue:
  - QUeue(self)   #创建空队列
  - is_empty(self) #判断队列是否为空，空时返回True否则返回False
  - enqueue(self, elem) #将元素elem加入队列，常称为**入队**
  - dequeue(self) #删除队列里最早进入的元素并将其返回，常称为**出队**
  - peek(self) #查看队列里最早进入的元素，不删除

- 队列基于链接表的实现：带尾端指针的单链表，支持O(1)时间的首端插入/删除操作，已经O(1)时间的尾端插入操作。
- 队列基于顺序表的实现:
  - 循环顺序表
- 队列的list实现

#### 迷宫求解和状态空间搜索
- 深度优先搜索(depth-first search)：基于栈的搜索
- 广度优先搜索(width-first search)：基于队列的搜索

#### 补充
- 双端队列：允许在两端插入和删除元素，因此功能上覆盖所有结构，要求两端的四种变动操作都应该具有O(1)时间复杂度。
  - 利用双链表可以实现双端队列
